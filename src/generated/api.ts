// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * SIKB-API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: v1
 * Contact: fkbf@kin-ball.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Affiliation
 */
export interface Affiliation {
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    prefectureNumber: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    prefectureCity: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    siretNumber: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    webSite?: string;
    /**
     * 
     * @type {Board}
     * @memberof Affiliation
     */
    board: Board;
    /**
     * 
     * @type {AffiliationStatus}
     * @memberof Affiliation
     */
    status: AffiliationStatus;
    /**
     * 
     * @type {string}
     * @memberof Affiliation
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof Affiliation
     */
    id: number;
}

/**
 * 
 * @export
 * @interface AffiliationForCreation
 */
export interface AffiliationForCreation {
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    prefectureNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    prefectureCity: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    siretNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    webSite?: string;
    /**
     * 
     * @type {BoardForCreation}
     * @memberof AffiliationForCreation
     */
    board: BoardForCreation;
    /**
     * 
     * @type {AffiliationStatus}
     * @memberof AffiliationForCreation
     */
    status?: AffiliationStatus;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForCreation
     */
    comment?: string;
}

/**
 * 
 * @export
 * @interface AffiliationForUpdate
 */
export interface AffiliationForUpdate {
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    prefectureNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    prefectureCity?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    siretNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    webSite?: string;
    /**
     * 
     * @type {Board}
     * @memberof AffiliationForUpdate
     */
    board?: Board;
    /**
     * 
     * @type {AffiliationStatus}
     * @memberof AffiliationForUpdate
     */
    status?: AffiliationStatus;
    /**
     * 
     * @type {string}
     * @memberof AffiliationForUpdate
     */
    comment?: string;
}

/**
 * Once an affiliation is created, if the status is not provided then it\'s initialized with TO_COMPLETE. Then available transitions are : - TO_COMPLETE ==> SUBMITTED - SUBMITTED ==> VALIDATED - SUBMITTED ==> TO_COMPLETE
 * @export
 * @enum {string}
 */
export enum AffiliationStatus {
    TOCOMPLETE = 'TO_COMPLETE',
    SUBMITTED = 'SUBMITTED',
    VALIDATED = 'VALIDATED'
}

/**
 * 
 * @export
 * @interface Board
 */
export interface Board {
    /**
     * 
     * @type {BoardMember}
     * @memberof Board
     */
    president: BoardMember;
    /**
     * 
     * @type {BoardMember}
     * @memberof Board
     */
    secretary: BoardMember;
    /**
     * 
     * @type {BoardMember}
     * @memberof Board
     */
    treasurer: BoardMember;
    /**
     * 
     * @type {number}
     * @memberof Board
     */
    membersNumber: number;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    electedDate: string;
}

/**
 * 
 * @export
 * @interface BoardForCreation
 */
export interface BoardForCreation {
    /**
     * 
     * @type {BoardMember}
     * @memberof BoardForCreation
     */
    president: BoardMember;
    /**
     * 
     * @type {BoardMember}
     * @memberof BoardForCreation
     */
    secretary: BoardMember;
    /**
     * 
     * @type {BoardMember}
     * @memberof BoardForCreation
     */
    treasurer: BoardMember;
    /**
     * 
     * @type {number}
     * @memberof BoardForCreation
     */
    membersNumber: number;
    /**
     * 
     * @type {string}
     * @memberof BoardForCreation
     */
    electedDate: string;
}

/**
 * 
 * @export
 * @interface BoardMember
 */
export interface BoardMember {
    /**
     * 
     * @type {string}
     * @memberof BoardMember
     */
    name: string;
    /**
     * 
     * @type {Sex}
     * @memberof BoardMember
     */
    sex: Sex;
}

/**
 * 
 * @export
 * @interface Club
 */
export interface Club {
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Club
     */
    shortName: string;
    /**
     * 
     * @type {number}
     * @memberof Club
     */
    id: number;
    /**
     * 
     * @type {Logo}
     * @memberof Club
     */
    logo?: Logo;
}

/**
 * 
 * @export
 * @interface ClubForCreation
 */
export interface ClubForCreation {
    /**
     * 
     * @type {string}
     * @memberof ClubForCreation
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ClubForCreation
     */
    shortName: string;
}

/**
 * 
 * @export
 * @interface ClubForUpdate
 */
export interface ClubForUpdate {
    /**
     * 
     * @type {string}
     * @memberof ClubForUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClubForUpdate
     */
    shortName?: string;
}

/**
 * 
 * @export
 * @interface ConfirmPassword
 */
export interface ConfirmPassword {
    /**
     * 
     * @type {string}
     * @memberof ConfirmPassword
     */
    newPassword: string;
}

/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    login: string;
    /**
     * 
     * @type {string}
     * @memberof Credentials
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Formation
 */
export interface Formation {
    /**
     * 
     * @type {number}
     * @memberof Formation
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Formation
     */
    date: string;
}

/**
 * 
 * @export
 * @interface FormationType
 */
export interface FormationType {
    /**
     * 
     * @type {number}
     * @memberof FormationType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FormationType
     */
    name: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Functionality {
    USERREAD = 'USER_READ',
    USERCREATE = 'USER_CREATE',
    USERUPDATE = 'USER_UPDATE',
    USERDELETE = 'USER_DELETE',
    CLUBREAD = 'CLUB_READ',
    CLUBCREATE = 'CLUB_CREATE',
    CLUBUPDATE = 'CLUB_UPDATE',
    CLUBDELETE = 'CLUB_DELETE',
    AFFILIATIONVALIDATE = 'AFFILIATION_VALIDATE',
    PERSONREAD = 'PERSON_READ',
    PERSONCREATE = 'PERSON_CREATE',
    PERSONUPDATE = 'PERSON_UPDATE',
    PERSONDELETE = 'PERSON_DELETE',
    SEASONREAD = 'SEASON_READ',
    SEASONCREATE = 'SEASON_CREATE',
    SEASONUPDATE = 'SEASON_UPDATE',
    SEASONDELETE = 'SEASON_DELETE'
}

/**
 * 
 * @export
 * @interface Licence
 */
export interface Licence {
    /**
     * 
     * @type {string}
     * @memberof Licence
     */
    number: string;
    /**
     * 
     * @type {Array<LicenceType>}
     * @memberof Licence
     */
    typeLicences: Array<LicenceType>;
    /**
     * 
     * @type {string}
     * @memberof Licence
     */
    season: string;
    /**
     * 
     * @type {Array<FormationType>}
     * @memberof Licence
     */
    formationNeed?: Array<FormationType>;
    /**
     * 
     * @type {number}
     * @memberof Licence
     */
    clubId: number;
}

/**
 * 
 * @export
 * @interface LicenceForCreation
 */
export interface LicenceForCreation {
    /**
     * ids of licence types
     * @type {Array<number>}
     * @memberof LicenceForCreation
     */
    typeLicences: Array<number>;
    /**
     * ids of formation types needed
     * @type {Array<number>}
     * @memberof LicenceForCreation
     */
    formationNeed?: Array<number>;
}

/**
 * 
 * @export
 * @interface LicenceForUpdate
 */
export interface LicenceForUpdate {
    /**
     * ids of licence types
     * @type {Array<number>}
     * @memberof LicenceForUpdate
     */
    typeLicences?: Array<number>;
    /**
     * ids of formation types needed
     * @type {Array<number>}
     * @memberof LicenceForUpdate
     */
    formationNeed?: Array<number>;
}

/**
 * 
 * @export
 * @interface LicenceType
 */
export interface LicenceType {
    /**
     * 
     * @type {number}
     * @memberof LicenceType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof LicenceType
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenceType
     */
    medicalCertificateRequired: boolean;
}

/**
 * 
 * @export
 * @interface Logo
 */
export interface Logo {
    /**
     * 
     * @type {string}
     * @memberof Logo
     */
    location: string;
}

/**
 * 
 * @export
 * @interface LogoForCreation
 */
export interface LogoForCreation {
    /**
     * 
     * @type {any}
     * @memberof LogoForCreation
     */
    logoFileName: any;
}

/**
 * 
 * @export
 * @interface MedicalCertificate
 */
export interface MedicalCertificate {
    /**
     * 
     * @type {string}
     * @memberof MedicalCertificate
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof MedicalCertificate
     */
    beginValidityDate: string;
}

/**
 * 
 * @export
 * @interface MedicalCertificateForCreation
 */
export interface MedicalCertificateForCreation {
    /**
     * 
     * @type {any}
     * @memberof MedicalCertificateForCreation
     */
    medicalCertificateFileName: any;
    /**
     * Format is YYYY-MM-DD. <br> There is a bug in some client so the date is sent as string without format:date
     * @type {string}
     * @memberof MedicalCertificateForCreation
     */
    medicalCertificateBeginValidityDate: string;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MemberType {
    PLAYER = 'PLAYER',
    COACH = 'COACH',
    ASSISTANT = 'ASSISTANT'
}

/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    name: string;
    /**
     * 
     * @type {Sex}
     * @memberof Person
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    nationality?: string;
    /**
     * 
     * @type {Array<Formation>}
     * @memberof Person
     */
    formations?: Array<Formation>;
    /**
     * 
     * @type {number}
     * @memberof Person
     */
    id: number;
    /**
     * 
     * @type {Photo}
     * @memberof Person
     */
    photo?: Photo;
    /**
     * 
     * @type {MedicalCertificate}
     * @memberof Person
     */
    medicalCertificate?: MedicalCertificate;
}

/**
 * 
 * @export
 * @interface PersonForCreation
 */
export interface PersonForCreation {
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    name: string;
    /**
     * 
     * @type {Sex}
     * @memberof PersonForCreation
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForCreation
     */
    nationality?: string;
    /**
     * 
     * @type {Array<Formation>}
     * @memberof PersonForCreation
     */
    formations?: Array<Formation>;
}

/**
 * 
 * @export
 * @interface PersonForUpdate
 */
export interface PersonForUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    name?: string;
    /**
     * 
     * @type {Sex}
     * @memberof PersonForUpdate
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonForUpdate
     */
    nationality?: string;
    /**
     * 
     * @type {Array<Formation>}
     * @memberof PersonForUpdate
     */
    formations?: Array<Formation>;
}

/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    location: string;
}

/**
 * 
 * @export
 * @interface PhotoForCreation
 */
export interface PhotoForCreation {
    /**
     * 
     * @type {any}
     * @memberof PhotoForCreation
     */
    photoFileName: any;
}

/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {ProfileType}
     * @memberof Profile
     */
    type: ProfileType;
    /**
     * 
     * @type {Array<number>}
     * @memberof Profile
     */
    clubIds: Array<number>;
}

/**
 * 
 * @export
 * @interface ProfileForCreation
 */
export interface ProfileForCreation {
    /**
     * 
     * @type {ProfileTypeForCreation}
     * @memberof ProfileForCreation
     */
    type: ProfileTypeForCreation;
    /**
     * 
     * @type {Array<number>}
     * @memberof ProfileForCreation
     */
    clubIds: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileForCreation
     */
    allClubs?: boolean;
}

/**
 * 
 * @export
 * @interface ProfileType
 */
export interface ProfileType {
    /**
     * 
     * @type {number}
     * @memberof ProfileType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileType
     */
    name: string;
    /**
     * 
     * @type {Array<Functionality>}
     * @memberof ProfileType
     */
    functionalities: Array<Functionality>;
}

/**
 * 
 * @export
 * @interface ProfileTypeForCreation
 */
export interface ProfileTypeForCreation {
    /**
     * 
     * @type {number}
     * @memberof ProfileTypeForCreation
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileTypeForCreation
     */
    name: string;
}

/**
 * 
 * @export
 * @interface Reset
 */
export interface Reset {
    /**
     * 
     * @type {string}
     * @memberof Reset
     */
    login: string;
}

/**
 * 
 * @export
 * @interface Season
 */
export interface Season {
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    begin: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    end: string;
    /**
     * 
     * @type {string}
     * @memberof Season
     */
    id: string;
}

/**
 * 
 * @export
 * @interface SeasonForCreation
 */
export interface SeasonForCreation {
    /**
     * 
     * @type {string}
     * @memberof SeasonForCreation
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof SeasonForCreation
     */
    begin: string;
    /**
     * 
     * @type {string}
     * @memberof SeasonForCreation
     */
    end: string;
}

/**
 * 
 * @export
 * @interface SeasonForUpdate
 */
export interface SeasonForUpdate {
    /**
     * 
     * @type {string}
     * @memberof SeasonForUpdate
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SeasonForUpdate
     */
    begin?: string;
    /**
     * 
     * @type {string}
     * @memberof SeasonForUpdate
     */
    end?: string;
}

/**
 * 
 * @export
 * @interface SeasonWithAffiliation
 */
export interface SeasonWithAffiliation {
    /**
     * 
     * @type {Season}
     * @memberof SeasonWithAffiliation
     */
    season: Season;
    /**
     * 
     * @type {Affiliation}
     * @memberof SeasonWithAffiliation
     */
    affiliation: Affiliation;
}

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    access_token: string;
    /**
     * 
     * @type {User}
     * @memberof Session
     */
    user: User;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Sex {
    MALE = 'MALE',
    FEMALE = 'FEMALE'
}

/**
 * 
 * @export
 * @interface Team
 */
export interface Team {
    /**
     * 
     * @type {number}
     * @memberof Team
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Team
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface TeamForCreation
 */
export interface TeamForCreation {
    /**
     * 
     * @type {string}
     * @memberof TeamForCreation
     */
    name: string;
    /**
     * 
     * @type {Array<TeamMemberForCreation>}
     * @memberof TeamForCreation
     */
    members?: Array<TeamMemberForCreation>;
}

/**
 * 
 * @export
 * @interface TeamForUpdate
 */
export interface TeamForUpdate {
    /**
     * 
     * @type {string}
     * @memberof TeamForUpdate
     */
    name?: string;
    /**
     * 
     * @type {Array<TeamMemberForCreation>}
     * @memberof TeamForUpdate
     */
    members?: Array<TeamMemberForCreation>;
}

/**
 * 
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
    /**
     * 
     * @type {Person}
     * @memberof TeamMember
     */
    member?: Person;
    /**
     * 
     * @type {MemberType}
     * @memberof TeamMember
     */
    type?: MemberType;
}

/**
 * 
 * @export
 * @interface TeamMemberForCreation
 */
export interface TeamMemberForCreation {
    /**
     * 
     * @type {number}
     * @memberof TeamMemberForCreation
     */
    id: number;
    /**
     * 
     * @type {MemberType}
     * @memberof TeamMemberForCreation
     */
    type: MemberType;
}

/**
 * 
 * @export
 * @interface UpdatePassword
 */
export interface UpdatePassword {
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    newPassword: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {Profile}
     * @memberof User
     */
    profile: Profile;
}

/**
 * 
 * @export
 * @interface UserForCreation
 */
export interface UserForCreation {
    /**
     * 
     * @type {string}
     * @memberof UserForCreation
     */
    email: string;
    /**
     * 
     * @type {ProfileForCreation}
     * @memberof UserForCreation
     */
    profile: ProfileForCreation;
}

/**
 * 
 * @export
 * @interface UserForUpdate
 */
export interface UserForUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserForUpdate
     */
    email?: string;
    /**
     * 
     * @type {ProfileForCreation}
     * @memberof UserForUpdate
     */
    profile?: ProfileForCreation;
}

/**
 * 
 * @export
 * @interface ZError
 */
export interface ZError {
    /**
     * 
     * @type {number}
     * @memberof ZError
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof ZError
     */
    message: string;
}


/**
 * AffiliationsApi - axios parameter creator
 * @export
 */
export const AffiliationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForCreation} AffiliationForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForCreation: AffiliationForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createAffiliation.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling createAffiliation.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling createAffiliation.');
            }
            // verify required parameter 'AffiliationForCreation' is not null or undefined
            if (AffiliationForCreation === null || AffiliationForCreation === undefined) {
                throw new RequiredError('AffiliationForCreation','Required parameter AffiliationForCreation was null or undefined when calling createAffiliation.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/affiliations`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AffiliationForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(AffiliationForCreation !== undefined ? AffiliationForCreation : {}) : (AffiliationForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliation(access_token: string, clubId: number, seasonId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deleteAffiliation.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling deleteAffiliation.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling deleteAffiliation.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/affiliations`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary find all club\'s affiliations
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubAffiliations(access_token: string, clubId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findAllClubAffiliations.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling findAllClubAffiliations.');
            }
            const localVarPath = `/clubs/{clubId}/affiliations`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliation(access_token: string, clubId: number, seasonId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getAffiliation.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling getAffiliation.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling getAffiliation.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/affiliations`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForUpdate} AffiliationForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForUpdate: AffiliationForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updateAffiliation.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling updateAffiliation.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling updateAffiliation.');
            }
            // verify required parameter 'AffiliationForUpdate' is not null or undefined
            if (AffiliationForUpdate === null || AffiliationForUpdate === undefined) {
                throw new RequiredError('AffiliationForUpdate','Required parameter AffiliationForUpdate was null or undefined when calling updateAffiliation.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/affiliations`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AffiliationForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(AffiliationForUpdate !== undefined ? AffiliationForUpdate : {}) : (AffiliationForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliationsApi - functional programming interface
 * @export
 */
export const AffiliationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForCreation} AffiliationForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForCreation: AffiliationForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Affiliation> {
            const localVarAxiosArgs = AffiliationsApiAxiosParamCreator(configuration).createAffiliation(access_token, clubId, seasonId, AffiliationForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliation(access_token: string, clubId: number, seasonId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = AffiliationsApiAxiosParamCreator(configuration).deleteAffiliation(access_token, clubId, seasonId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary find all club\'s affiliations
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubAffiliations(access_token: string, clubId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SeasonWithAffiliation>> {
            const localVarAxiosArgs = AffiliationsApiAxiosParamCreator(configuration).findAllClubAffiliations(access_token, clubId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliation(access_token: string, clubId: number, seasonId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Affiliation> {
            const localVarAxiosArgs = AffiliationsApiAxiosParamCreator(configuration).getAffiliation(access_token, clubId, seasonId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForUpdate} AffiliationForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForUpdate: AffiliationForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Affiliation> {
            const localVarAxiosArgs = AffiliationsApiAxiosParamCreator(configuration).updateAffiliation(access_token, clubId, seasonId, AffiliationForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AffiliationsApi - factory interface
 * @export
 */
export const AffiliationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForCreation} AffiliationForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForCreation: AffiliationForCreation, options?: any) {
            return AffiliationsApiFp(configuration).createAffiliation(access_token, clubId, seasonId, AffiliationForCreation, options)(axios, basePath);
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliation(access_token: string, clubId: number, seasonId: string, options?: any) {
            return AffiliationsApiFp(configuration).deleteAffiliation(access_token, clubId, seasonId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary find all club\'s affiliations
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClubAffiliations(access_token: string, clubId: number, options?: any) {
            return AffiliationsApiFp(configuration).findAllClubAffiliations(access_token, clubId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary get the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliation(access_token: string, clubId: number, seasonId: string, options?: any) {
            return AffiliationsApiFp(configuration).getAffiliation(access_token, clubId, seasonId, options)(axios, basePath);
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club affiliation for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {AffiliationForUpdate} AffiliationForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForUpdate: AffiliationForUpdate, options?: any) {
            return AffiliationsApiFp(configuration).updateAffiliation(access_token, clubId, seasonId, AffiliationForUpdate, options)(axios, basePath);
        },
    };
};

/**
 * AffiliationsApi - object-oriented interface
 * @export
 * @class AffiliationsApi
 * @extends {BaseAPI}
 */
export class AffiliationsApi extends BaseAPI {
    /**
     * Require CLUB_CREATE right
     * @summary Create the club affiliation for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {AffiliationForCreation} AffiliationForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliationsApi
     */
    public createAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForCreation: AffiliationForCreation, options?: any) {
        return AffiliationsApiFp(this.configuration).createAffiliation(access_token, clubId, seasonId, AffiliationForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_DELETE right
     * @summary Delete the club affiliation for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliationsApi
     */
    public deleteAffiliation(access_token: string, clubId: number, seasonId: string, options?: any) {
        return AffiliationsApiFp(this.configuration).deleteAffiliation(access_token, clubId, seasonId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary find all club\'s affiliations
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliationsApi
     */
    public findAllClubAffiliations(access_token: string, clubId: number, options?: any) {
        return AffiliationsApiFp(this.configuration).findAllClubAffiliations(access_token, clubId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary get the club affiliation for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliationsApi
     */
    public getAffiliation(access_token: string, clubId: number, seasonId: string, options?: any) {
        return AffiliationsApiFp(this.configuration).getAffiliation(access_token, clubId, seasonId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_UPDATE right
     * @summary Update the club affiliation for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {AffiliationForUpdate} AffiliationForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliationsApi
     */
    public updateAffiliation(access_token: string, clubId: number, seasonId: string, AffiliationForUpdate: AffiliationForUpdate, options?: any) {
        return AffiliationsApiFp(this.configuration).updateAffiliation(access_token, clubId, seasonId, AffiliationForUpdate, options)(this.axios, this.basePath);
    }

}


/**
 * ClubsApi - axios parameter creator
 * @export
 */
export const ClubsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {ClubForCreation} ClubForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClub(access_token: string, ClubForCreation: ClubForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createClub.');
            }
            // verify required parameter 'ClubForCreation' is not null or undefined
            if (ClubForCreation === null || ClubForCreation === undefined) {
                throw new RequiredError('ClubForCreation','Required parameter ClubForCreation was null or undefined when calling createClub.');
            }
            const localVarPath = `/clubs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ClubForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ClubForCreation !== undefined ? ClubForCreation : {}) : (ClubForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClub(access_token: string, clubId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deleteClub.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling deleteClub.');
            }
            const localVarPath = `/clubs/{clubId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary Find all club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubs(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findClubs.');
            }
            const localVarPath = `/clubs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(access_token: string, clubId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getClubById.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling getClubById.');
            }
            const localVarPath = `/clubs/{clubId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {ClubForUpdate} ClubForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClub(access_token: string, clubId: number, ClubForUpdate: ClubForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updateClub.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling updateClub.');
            }
            // verify required parameter 'ClubForUpdate' is not null or undefined
            if (ClubForUpdate === null || ClubForUpdate === undefined) {
                throw new RequiredError('ClubForUpdate','Required parameter ClubForUpdate was null or undefined when calling updateClub.');
            }
            const localVarPath = `/clubs/{clubId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ClubForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ClubForUpdate !== undefined ? ClubForUpdate : {}) : (ClubForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_CREATE right
         * @summary Upload a club\'s
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {any} logoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLogo(access_token: string, clubId: number, logoFileName: any, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling uploadLogo.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling uploadLogo.');
            }
            // verify required parameter 'logoFileName' is not null or undefined
            if (logoFileName === null || logoFileName === undefined) {
                throw new RequiredError('logoFileName','Required parameter logoFileName was null or undefined when calling uploadLogo.');
            }
            const localVarPath = `/clubs/{clubId}/logo`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


            if (logoFileName !== undefined) { 
                localVarFormParams.append('logoFileName', logoFileName as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {ClubForCreation} ClubForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClub(access_token: string, ClubForCreation: ClubForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).createClub(access_token, ClubForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClub(access_token: string, clubId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).deleteClub(access_token, clubId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary Find all club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubs(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Club>> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).findClubs(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(access_token: string, clubId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).getClubById(access_token, clubId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {ClubForUpdate} ClubForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClub(access_token: string, clubId: number, ClubForUpdate: ClubForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Club> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).updateClub(access_token, clubId, ClubForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_CREATE right
         * @summary Upload a club\'s
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {any} logoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLogo(access_token: string, clubId: number, logoFileName: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo> {
            const localVarAxiosArgs = ClubsApiAxiosParamCreator(configuration).uploadLogo(access_token, clubId, logoFileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {ClubForCreation} ClubForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClub(access_token: string, ClubForCreation: ClubForCreation, options?: any) {
            return ClubsApiFp(configuration).createClub(access_token, ClubForCreation, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClub(access_token: string, clubId: number, options?: any) {
            return ClubsApiFp(configuration).deleteClub(access_token, clubId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary Find all club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClubs(access_token: string, options?: any) {
            return ClubsApiFp(configuration).findClubs(access_token, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary get a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(access_token: string, clubId: number, options?: any) {
            return ClubsApiFp(configuration).getClubById(access_token, clubId, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update a club
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {ClubForUpdate} ClubForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClub(access_token: string, clubId: number, ClubForUpdate: ClubForUpdate, options?: any) {
            return ClubsApiFp(configuration).updateClub(access_token, clubId, ClubForUpdate, options)(axios, basePath);
        },
        /**
         * Require CLUB_CREATE right
         * @summary Upload a club\'s
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {any} logoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLogo(access_token: string, clubId: number, logoFileName: any, options?: any) {
            return ClubsApiFp(configuration).uploadLogo(access_token, clubId, logoFileName, options)(axios, basePath);
        },
    };
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     * Require CLUB_CREATE right
     * @summary Create a club
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {ClubForCreation} ClubForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public createClub(access_token: string, ClubForCreation: ClubForCreation, options?: any) {
        return ClubsApiFp(this.configuration).createClub(access_token, ClubForCreation, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete a club
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public deleteClub(access_token: string, clubId: number, options?: any) {
        return ClubsApiFp(this.configuration).deleteClub(access_token, clubId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary Find all club
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public findClubs(access_token: string, options?: any) {
        return ClubsApiFp(this.configuration).findClubs(access_token, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary get a club
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubById(access_token: string, clubId: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubById(access_token, clubId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update a club
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {ClubForUpdate} ClubForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public updateClub(access_token: string, clubId: number, ClubForUpdate: ClubForUpdate, options?: any) {
        return ClubsApiFp(this.configuration).updateClub(access_token, clubId, ClubForUpdate, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_CREATE right
     * @summary Upload a club\'s
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {any} logoFileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public uploadLogo(access_token: string, clubId: number, logoFileName: any, options?: any) {
        return ClubsApiFp(this.configuration).uploadLogo(access_token, clubId, logoFileName, options)(this.axios, this.basePath);
    }

}


/**
 * ConfigurationsApi - axios parameter creator
 * @export
 */
export const ConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require SEASON_CREATE right
         * @summary Create a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {SeasonForCreation} SeasonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason(access_token: string, SeasonForCreation: SeasonForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createSeason.');
            }
            // verify required parameter 'SeasonForCreation' is not null or undefined
            if (SeasonForCreation === null || SeasonForCreation === undefined) {
                throw new RequiredError('SeasonForCreation','Required parameter SeasonForCreation was null or undefined when calling createSeason.');
            }
            const localVarPath = `/seasons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"SeasonForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(SeasonForCreation !== undefined ? SeasonForCreation : {}) : (SeasonForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require SEASON_DELETE right
         * @summary Delete a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeason(access_token: string, seasonId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deleteSeason.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling deleteSeason.');
            }
            const localVarPath = `/seasons/{seasonId}`
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No right Required
         * @summary Find all formation types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFormationTypes(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findFormationTypes.');
            }
            const localVarPath = `/formationTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No right Required
         * @summary Find all licence types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLicenceTypes(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findLicenceTypes.');
            }
            const localVarPath = `/licenceTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No right Required
         * @summary Find all profile types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProfileTypes(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findProfileTypes.');
            }
            const localVarPath = `/profileTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * No right Required
         * @summary Find all seasons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeasons(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findSeasons.');
            }
            const localVarPath = `/seasons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require SEASON_UPDATE right
         * @summary Update a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {SeasonForUpdate} SeasonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason(access_token: string, seasonId: string, SeasonForUpdate: SeasonForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updateSeason.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling updateSeason.');
            }
            // verify required parameter 'SeasonForUpdate' is not null or undefined
            if (SeasonForUpdate === null || SeasonForUpdate === undefined) {
                throw new RequiredError('SeasonForUpdate','Required parameter SeasonForUpdate was null or undefined when calling updateSeason.');
            }
            const localVarPath = `/seasons/{seasonId}`
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"SeasonForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(SeasonForUpdate !== undefined ? SeasonForUpdate : {}) : (SeasonForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationsApi - functional programming interface
 * @export
 */
export const ConfigurationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require SEASON_CREATE right
         * @summary Create a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {SeasonForCreation} SeasonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason(access_token: string, SeasonForCreation: SeasonForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).createSeason(access_token, SeasonForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require SEASON_DELETE right
         * @summary Delete a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeason(access_token: string, seasonId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).deleteSeason(access_token, seasonId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No right Required
         * @summary Find all formation types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFormationTypes(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FormationType>> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).findFormationTypes(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No right Required
         * @summary Find all licence types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLicenceTypes(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LicenceType>> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).findLicenceTypes(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No right Required
         * @summary Find all profile types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProfileTypes(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProfileType>> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).findProfileTypes(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * No right Required
         * @summary Find all seasons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeasons(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Season>> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).findSeasons(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require SEASON_UPDATE right
         * @summary Update a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {SeasonForUpdate} SeasonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason(access_token: string, seasonId: string, SeasonForUpdate: SeasonForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Season> {
            const localVarAxiosArgs = ConfigurationsApiAxiosParamCreator(configuration).updateSeason(access_token, seasonId, SeasonForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigurationsApi - factory interface
 * @export
 */
export const ConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require SEASON_CREATE right
         * @summary Create a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {SeasonForCreation} SeasonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeason(access_token: string, SeasonForCreation: SeasonForCreation, options?: any) {
            return ConfigurationsApiFp(configuration).createSeason(access_token, SeasonForCreation, options)(axios, basePath);
        },
        /**
         * Require SEASON_DELETE right
         * @summary Delete a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSeason(access_token: string, seasonId: string, options?: any) {
            return ConfigurationsApiFp(configuration).deleteSeason(access_token, seasonId, options)(axios, basePath);
        },
        /**
         * No right Required
         * @summary Find all formation types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFormationTypes(access_token: string, options?: any) {
            return ConfigurationsApiFp(configuration).findFormationTypes(access_token, options)(axios, basePath);
        },
        /**
         * No right Required
         * @summary Find all licence types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLicenceTypes(access_token: string, options?: any) {
            return ConfigurationsApiFp(configuration).findLicenceTypes(access_token, options)(axios, basePath);
        },
        /**
         * No right Required
         * @summary Find all profile types
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProfileTypes(access_token: string, options?: any) {
            return ConfigurationsApiFp(configuration).findProfileTypes(access_token, options)(axios, basePath);
        },
        /**
         * No right Required
         * @summary Find all seasons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSeasons(access_token: string, options?: any) {
            return ConfigurationsApiFp(configuration).findSeasons(access_token, options)(axios, basePath);
        },
        /**
         * Require SEASON_UPDATE right
         * @summary Update a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} seasonId identifications of the season
         * @param {SeasonForUpdate} SeasonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeason(access_token: string, seasonId: string, SeasonForUpdate: SeasonForUpdate, options?: any) {
            return ConfigurationsApiFp(configuration).updateSeason(access_token, seasonId, SeasonForUpdate, options)(axios, basePath);
        },
    };
};

/**
 * ConfigurationsApi - object-oriented interface
 * @export
 * @class ConfigurationsApi
 * @extends {BaseAPI}
 */
export class ConfigurationsApi extends BaseAPI {
    /**
     * Require SEASON_CREATE right
     * @summary Create a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {SeasonForCreation} SeasonForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public createSeason(access_token: string, SeasonForCreation: SeasonForCreation, options?: any) {
        return ConfigurationsApiFp(this.configuration).createSeason(access_token, SeasonForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require SEASON_DELETE right
     * @summary Delete a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {string} seasonId identifications of the season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public deleteSeason(access_token: string, seasonId: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).deleteSeason(access_token, seasonId, options)(this.axios, this.basePath);
    }

    /**
     * No right Required
     * @summary Find all formation types
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public findFormationTypes(access_token: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).findFormationTypes(access_token, options)(this.axios, this.basePath);
    }

    /**
     * No right Required
     * @summary Find all licence types
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public findLicenceTypes(access_token: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).findLicenceTypes(access_token, options)(this.axios, this.basePath);
    }

    /**
     * No right Required
     * @summary Find all profile types
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public findProfileTypes(access_token: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).findProfileTypes(access_token, options)(this.axios, this.basePath);
    }

    /**
     * No right Required
     * @summary Find all seasons
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public findSeasons(access_token: string, options?: any) {
        return ConfigurationsApiFp(this.configuration).findSeasons(access_token, options)(this.axios, this.basePath);
    }

    /**
     * Require SEASON_UPDATE right
     * @summary Update a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {string} seasonId identifications of the season
     * @param {SeasonForUpdate} SeasonForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationsApi
     */
    public updateSeason(access_token: string, seasonId: string, SeasonForUpdate: SeasonForUpdate, options?: any) {
        return ConfigurationsApiFp(this.configuration).updateSeason(access_token, seasonId, SeasonForUpdate, options)(this.axios, this.basePath);
    }

}


/**
 * IdentificationsApi - axios parameter creator
 * @export
 */
export const IdentificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A mail was sent to the user email address with a link to confirm his email and set his password
         * @summary Confirm user email
         * @param {string} confirmToken Token to confirm email address
         * @param {ConfirmPassword} ConfirmPassword body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(confirmToken: string, ConfirmPassword: ConfirmPassword, options: any = {}): RequestArgs {
            // verify required parameter 'confirmToken' is not null or undefined
            if (confirmToken === null || confirmToken === undefined) {
                throw new RequiredError('confirmToken','Required parameter confirmToken was null or undefined when calling userConfirm.');
            }
            // verify required parameter 'ConfirmPassword' is not null or undefined
            if (ConfirmPassword === null || ConfirmPassword === undefined) {
                throw new RequiredError('ConfirmPassword','Required parameter ConfirmPassword was null or undefined when calling userConfirm.');
            }
            const localVarPath = `/users/confirm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (confirmToken !== undefined) {
                localVarQueryParameter['confirmToken'] = confirmToken;
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ConfirmPassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ConfirmPassword !== undefined ? ConfirmPassword : {}) : (ConfirmPassword || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log in a user
         * @param {Credentials} Credentials body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(Credentials: Credentials, options: any = {}): RequestArgs {
            // verify required parameter 'Credentials' is not null or undefined
            if (Credentials === null || Credentials === undefined) {
                throw new RequiredError('Credentials','Required parameter Credentials was null or undefined when calling userLogin.');
            }
            const localVarPath = `/users/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Credentials" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(Credentials !== undefined ? Credentials : {}) : (Credentials || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Log out a user (Revoke access Token)
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling userLogout.');
            }
            const localVarPath = `/users/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ask to reset a password
         * @param {Reset} Reset body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReset(Reset: Reset, options: any = {}): RequestArgs {
            // verify required parameter 'Reset' is not null or undefined
            if (Reset === null || Reset === undefined) {
                throw new RequiredError('Reset','Required parameter Reset was null or undefined when calling userReset.');
            }
            const localVarPath = `/users/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"Reset" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(Reset !== undefined ? Reset : {}) : (Reset || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can update either being log (access token is required) or unlog but you will need the resetToken in the mail sent by the reset password API
         * @summary Update the user password
         * @param {UpdatePassword} UpdatePassword body
         * @param {string} [access_token] Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} [resetToken] Token to reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(UpdatePassword: UpdatePassword, access_token?: string, resetToken?: string, options: any = {}): RequestArgs {
            // verify required parameter 'UpdatePassword' is not null or undefined
            if (UpdatePassword === null || UpdatePassword === undefined) {
                throw new RequiredError('UpdatePassword','Required parameter UpdatePassword was null or undefined when calling userUpdatePassword.');
            }
            const localVarPath = `/users/updatePassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (resetToken !== undefined) {
                localVarQueryParameter['resetToken'] = resetToken;
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"UpdatePassword" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(UpdatePassword !== undefined ? UpdatePassword : {}) : (UpdatePassword || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentificationsApi - functional programming interface
 * @export
 */
export const IdentificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A mail was sent to the user email address with a link to confirm his email and set his password
         * @summary Confirm user email
         * @param {string} confirmToken Token to confirm email address
         * @param {ConfirmPassword} ConfirmPassword body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(confirmToken: string, ConfirmPassword: ConfirmPassword, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IdentificationsApiAxiosParamCreator(configuration).userConfirm(confirmToken, ConfirmPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Log in a user
         * @param {Credentials} Credentials body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(Credentials: Credentials, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session> {
            const localVarAxiosArgs = IdentificationsApiAxiosParamCreator(configuration).userLogin(Credentials, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Log out a user (Revoke access Token)
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IdentificationsApiAxiosParamCreator(configuration).userLogout(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Ask to reset a password
         * @param {Reset} Reset body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReset(Reset: Reset, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IdentificationsApiAxiosParamCreator(configuration).userReset(Reset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * You can update either being log (access token is required) or unlog but you will need the resetToken in the mail sent by the reset password API
         * @summary Update the user password
         * @param {UpdatePassword} UpdatePassword body
         * @param {string} [access_token] Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} [resetToken] Token to reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(UpdatePassword: UpdatePassword, access_token?: string, resetToken?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = IdentificationsApiAxiosParamCreator(configuration).userUpdatePassword(UpdatePassword, access_token, resetToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IdentificationsApi - factory interface
 * @export
 */
export const IdentificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A mail was sent to the user email address with a link to confirm his email and set his password
         * @summary Confirm user email
         * @param {string} confirmToken Token to confirm email address
         * @param {ConfirmPassword} ConfirmPassword body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userConfirm(confirmToken: string, ConfirmPassword: ConfirmPassword, options?: any) {
            return IdentificationsApiFp(configuration).userConfirm(confirmToken, ConfirmPassword, options)(axios, basePath);
        },
        /**
         * 
         * @summary Log in a user
         * @param {Credentials} Credentials body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(Credentials: Credentials, options?: any) {
            return IdentificationsApiFp(configuration).userLogin(Credentials, options)(axios, basePath);
        },
        /**
         * 
         * @summary Log out a user (Revoke access Token)
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogout(access_token: string, options?: any) {
            return IdentificationsApiFp(configuration).userLogout(access_token, options)(axios, basePath);
        },
        /**
         * 
         * @summary Ask to reset a password
         * @param {Reset} Reset body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userReset(Reset: Reset, options?: any) {
            return IdentificationsApiFp(configuration).userReset(Reset, options)(axios, basePath);
        },
        /**
         * You can update either being log (access token is required) or unlog but you will need the resetToken in the mail sent by the reset password API
         * @summary Update the user password
         * @param {UpdatePassword} UpdatePassword body
         * @param {string} [access_token] Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {string} [resetToken] Token to reset password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(UpdatePassword: UpdatePassword, access_token?: string, resetToken?: string, options?: any) {
            return IdentificationsApiFp(configuration).userUpdatePassword(UpdatePassword, access_token, resetToken, options)(axios, basePath);
        },
    };
};

/**
 * IdentificationsApi - object-oriented interface
 * @export
 * @class IdentificationsApi
 * @extends {BaseAPI}
 */
export class IdentificationsApi extends BaseAPI {
    /**
     * A mail was sent to the user email address with a link to confirm his email and set his password
     * @summary Confirm user email
     * @param {string} confirmToken Token to confirm email address
     * @param {ConfirmPassword} ConfirmPassword body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public userConfirm(confirmToken: string, ConfirmPassword: ConfirmPassword, options?: any) {
        return IdentificationsApiFp(this.configuration).userConfirm(confirmToken, ConfirmPassword, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Log in a user
     * @param {Credentials} Credentials body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public userLogin(Credentials: Credentials, options?: any) {
        return IdentificationsApiFp(this.configuration).userLogin(Credentials, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Log out a user (Revoke access Token)
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public userLogout(access_token: string, options?: any) {
        return IdentificationsApiFp(this.configuration).userLogout(access_token, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Ask to reset a password
     * @param {Reset} Reset body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public userReset(Reset: Reset, options?: any) {
        return IdentificationsApiFp(this.configuration).userReset(Reset, options)(this.axios, this.basePath);
    }

    /**
     * You can update either being log (access token is required) or unlog but you will need the resetToken in the mail sent by the reset password API
     * @summary Update the user password
     * @param {UpdatePassword} UpdatePassword body
     * @param {string} [access_token] Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {string} [resetToken] Token to reset password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentificationsApi
     */
    public userUpdatePassword(UpdatePassword: UpdatePassword, access_token?: string, resetToken?: string, options?: any) {
        return IdentificationsApiFp(this.configuration).userUpdatePassword(UpdatePassword, access_token, resetToken, options)(this.axios, this.basePath);
    }

}


/**
 * LicencesApi - axios parameter creator
 * @export
 */
export const LicencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {LicenceForCreation} LicenceForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, LicenceForCreation: LicenceForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createPersonLicence.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling createPersonLicence.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling createPersonLicence.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling createPersonLicence.');
            }
            // verify required parameter 'LicenceForCreation' is not null or undefined
            if (LicenceForCreation === null || LicenceForCreation === undefined) {
                throw new RequiredError('LicenceForCreation','Required parameter LicenceForCreation was null or undefined when calling createPersonLicence.');
            }
            const localVarPath = `/persons/{personId}/clubs/{clubId}/seasons/{seasonId}/licences`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"LicenceForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(LicenceForCreation !== undefined ? LicenceForCreation : {}) : (LicenceForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deletePersonLicence.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling deletePersonLicence.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling deletePersonLicence.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling deletePersonLicence.');
            }
            // verify required parameter 'licenceId' is not null or undefined
            if (licenceId === null || licenceId === undefined) {
                throw new RequiredError('licenceId','Required parameter licenceId was null or undefined when calling deletePersonLicence.');
            }
            const localVarPath = `/persons/{personId}/clubs/{clubId}/seasons/{seasonId}/licences/{licenceId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"licenceId"}}`, encodeURIComponent(String(licenceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_READ right
         * @summary get a person\'s licences
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicences(access_token: string, personId: number, clubId: number, seasonId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getLicences.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling getLicences.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling getLicences.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling getLicences.');
            }
            const localVarPath = `/persons/{personId}/clubs/{clubId}/seasons/{seasonId}/licences`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {LicenceForUpdate} LicenceForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, LicenceForUpdate: LicenceForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updatePersonLicence.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling updatePersonLicence.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling updatePersonLicence.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling updatePersonLicence.');
            }
            // verify required parameter 'licenceId' is not null or undefined
            if (licenceId === null || licenceId === undefined) {
                throw new RequiredError('licenceId','Required parameter licenceId was null or undefined when calling updatePersonLicence.');
            }
            // verify required parameter 'LicenceForUpdate' is not null or undefined
            if (LicenceForUpdate === null || LicenceForUpdate === undefined) {
                throw new RequiredError('LicenceForUpdate','Required parameter LicenceForUpdate was null or undefined when calling updatePersonLicence.');
            }
            const localVarPath = `/persons/{personId}/clubs/{clubId}/seasons/{seasonId}/licences/{licenceId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)))
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"licenceId"}}`, encodeURIComponent(String(licenceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"LicenceForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(LicenceForUpdate !== undefined ? LicenceForUpdate : {}) : (LicenceForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicencesApi - functional programming interface
 * @export
 */
export const LicencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {LicenceForCreation} LicenceForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, LicenceForCreation: LicenceForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Licence> {
            const localVarAxiosArgs = LicencesApiAxiosParamCreator(configuration).createPersonLicence(access_token, personId, clubId, seasonId, LicenceForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = LicencesApiAxiosParamCreator(configuration).deletePersonLicence(access_token, personId, clubId, seasonId, licenceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_READ right
         * @summary get a person\'s licences
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicences(access_token: string, personId: number, clubId: number, seasonId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Licence>> {
            const localVarAxiosArgs = LicencesApiAxiosParamCreator(configuration).getLicences(access_token, personId, clubId, seasonId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {LicenceForUpdate} LicenceForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, LicenceForUpdate: LicenceForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Licence> {
            const localVarAxiosArgs = LicencesApiAxiosParamCreator(configuration).updatePersonLicence(access_token, personId, clubId, seasonId, licenceId, LicenceForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LicencesApi - factory interface
 * @export
 */
export const LicencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {LicenceForCreation} LicenceForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, LicenceForCreation: LicenceForCreation, options?: any) {
            return LicencesApiFp(configuration).createPersonLicence(access_token, personId, clubId, seasonId, LicenceForCreation, options)(axios, basePath);
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, options?: any) {
            return LicencesApiFp(configuration).deletePersonLicence(access_token, personId, clubId, seasonId, licenceId, options)(axios, basePath);
        },
        /**
         * Require PERSON_READ right
         * @summary get a person\'s licences
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicences(access_token: string, personId: number, clubId: number, seasonId: string, options?: any) {
            return LicencesApiFp(configuration).getLicences(access_token, personId, clubId, seasonId, options)(axios, basePath);
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person\'s licence
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {string} licenceId identifications of the licence
         * @param {LicenceForUpdate} LicenceForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, LicenceForUpdate: LicenceForUpdate, options?: any) {
            return LicencesApiFp(configuration).updatePersonLicence(access_token, personId, clubId, seasonId, licenceId, LicenceForUpdate, options)(axios, basePath);
        },
    };
};

/**
 * LicencesApi - object-oriented interface
 * @export
 * @class LicencesApi
 * @extends {BaseAPI}
 */
export class LicencesApi extends BaseAPI {
    /**
     * Require PERSON_CREATE right
     * @summary Create a person\'s licence
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {LicenceForCreation} LicenceForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicencesApi
     */
    public createPersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, LicenceForCreation: LicenceForCreation, options?: any) {
        return LicencesApiFp(this.configuration).createPersonLicence(access_token, personId, clubId, seasonId, LicenceForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_DELETE right
     * @summary Delete a person\'s licence
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {string} licenceId identifications of the licence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicencesApi
     */
    public deletePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, options?: any) {
        return LicencesApiFp(this.configuration).deletePersonLicence(access_token, personId, clubId, seasonId, licenceId, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_READ right
     * @summary get a person\'s licences
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicencesApi
     */
    public getLicences(access_token: string, personId: number, clubId: number, seasonId: string, options?: any) {
        return LicencesApiFp(this.configuration).getLicences(access_token, personId, clubId, seasonId, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_UPDATE right
     * @summary Update a person\'s licence
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {string} licenceId identifications of the licence
     * @param {LicenceForUpdate} LicenceForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicencesApi
     */
    public updatePersonLicence(access_token: string, personId: number, clubId: number, seasonId: string, licenceId: string, LicenceForUpdate: LicenceForUpdate, options?: any) {
        return LicencesApiFp(this.configuration).updatePersonLicence(access_token, personId, clubId, seasonId, licenceId, LicenceForUpdate, options)(this.axios, this.basePath);
    }

}


/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {PersonForCreation} PersonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(access_token: string, PersonForCreation: PersonForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createPerson.');
            }
            // verify required parameter 'PersonForCreation' is not null or undefined
            if (PersonForCreation === null || PersonForCreation === undefined) {
                throw new RequiredError('PersonForCreation','Required parameter PersonForCreation was null or undefined when calling createPerson.');
            }
            const localVarPath = `/persons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PersonForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(PersonForCreation !== undefined ? PersonForCreation : {}) : (PersonForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(access_token: string, personId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deletePerson.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling deletePerson.');
            }
            const localVarPath = `/persons/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_READ right
         * @summary Find all persons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersons(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findPersons.');
            }
            const localVarPath = `/persons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_READ right
         * @summary get a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(access_token: string, personId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getPerson.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling getPerson.');
            }
            const localVarPath = `/persons/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {PersonForUpdate} PersonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(access_token: string, personId: number, PersonForUpdate: PersonForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updatePerson.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling updatePerson.');
            }
            // verify required parameter 'PersonForUpdate' is not null or undefined
            if (PersonForUpdate === null || PersonForUpdate === undefined) {
                throw new RequiredError('PersonForUpdate','Required parameter PersonForUpdate was null or undefined when calling updatePerson.');
            }
            const localVarPath = `/persons/{personId}`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PersonForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(PersonForUpdate !== undefined ? PersonForUpdate : {}) : (PersonForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s medical certificate
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} medicalCertificateFileName 
         * @param {string} medicalCertificateBeginValidityDate Format is YYYY-MM-DD. &lt;br&gt; There is a bug in some client so the date is sent as string without format:date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedicalCertificate(access_token: string, personId: number, medicalCertificateFileName: any, medicalCertificateBeginValidityDate: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling uploadMedicalCertificate.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling uploadMedicalCertificate.');
            }
            // verify required parameter 'medicalCertificateFileName' is not null or undefined
            if (medicalCertificateFileName === null || medicalCertificateFileName === undefined) {
                throw new RequiredError('medicalCertificateFileName','Required parameter medicalCertificateFileName was null or undefined when calling uploadMedicalCertificate.');
            }
            // verify required parameter 'medicalCertificateBeginValidityDate' is not null or undefined
            if (medicalCertificateBeginValidityDate === null || medicalCertificateBeginValidityDate === undefined) {
                throw new RequiredError('medicalCertificateBeginValidityDate','Required parameter medicalCertificateBeginValidityDate was null or undefined when calling uploadMedicalCertificate.');
            }
            const localVarPath = `/persons/{personId}/medicalCertificate`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


            if (medicalCertificateFileName !== undefined) { 
                localVarFormParams.append('medicalCertificateFileName', medicalCertificateFileName as any);
            }
    
            if (medicalCertificateBeginValidityDate !== undefined) { 
                localVarFormParams.append('medicalCertificateBeginValidityDate', medicalCertificateBeginValidityDate as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s photo
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} photoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhoto(access_token: string, personId: number, photoFileName: any, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling uploadPhoto.');
            }
            // verify required parameter 'personId' is not null or undefined
            if (personId === null || personId === undefined) {
                throw new RequiredError('personId','Required parameter personId was null or undefined when calling uploadPhoto.');
            }
            // verify required parameter 'photoFileName' is not null or undefined
            if (photoFileName === null || photoFileName === undefined) {
                throw new RequiredError('photoFileName','Required parameter photoFileName was null or undefined when calling uploadPhoto.');
            }
            const localVarPath = `/persons/{personId}/photo`
                .replace(`{${"personId"}}`, encodeURIComponent(String(personId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


            if (photoFileName !== undefined) { 
                localVarFormParams.append('photoFileName', photoFileName as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {PersonForCreation} PersonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(access_token: string, PersonForCreation: PersonForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).createPerson(access_token, PersonForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(access_token: string, personId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).deletePerson(access_token, personId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_READ right
         * @summary Find all persons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersons(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Person>> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).findPersons(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_READ right
         * @summary get a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(access_token: string, personId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).getPerson(access_token, personId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {PersonForUpdate} PersonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(access_token: string, personId: number, PersonForUpdate: PersonForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Person> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).updatePerson(access_token, personId, PersonForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s medical certificate
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} medicalCertificateFileName 
         * @param {string} medicalCertificateBeginValidityDate Format is YYYY-MM-DD. &lt;br&gt; There is a bug in some client so the date is sent as string without format:date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedicalCertificate(access_token: string, personId: number, medicalCertificateFileName: any, medicalCertificateBeginValidityDate: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MedicalCertificate> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).uploadMedicalCertificate(access_token, personId, medicalCertificateFileName, medicalCertificateBeginValidityDate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s photo
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} photoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhoto(access_token: string, personId: number, photoFileName: any, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo> {
            const localVarAxiosArgs = PersonsApiAxiosParamCreator(configuration).uploadPhoto(access_token, personId, photoFileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require PERSON_CREATE right
         * @summary Create a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {PersonForCreation} PersonForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPerson(access_token: string, PersonForCreation: PersonForCreation, options?: any) {
            return PersonsApiFp(configuration).createPerson(access_token, PersonForCreation, options)(axios, basePath);
        },
        /**
         * Require PERSON_DELETE right
         * @summary Delete a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerson(access_token: string, personId: number, options?: any) {
            return PersonsApiFp(configuration).deletePerson(access_token, personId, options)(axios, basePath);
        },
        /**
         * Require PERSON_READ right
         * @summary Find all persons
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPersons(access_token: string, options?: any) {
            return PersonsApiFp(configuration).findPersons(access_token, options)(axios, basePath);
        },
        /**
         * Require PERSON_READ right
         * @summary get a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(access_token: string, personId: number, options?: any) {
            return PersonsApiFp(configuration).getPerson(access_token, personId, options)(axios, basePath);
        },
        /**
         * Require PERSON_UPDATE right
         * @summary Update a person
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {PersonForUpdate} PersonForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePerson(access_token: string, personId: number, PersonForUpdate: PersonForUpdate, options?: any) {
            return PersonsApiFp(configuration).updatePerson(access_token, personId, PersonForUpdate, options)(axios, basePath);
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s medical certificate
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} medicalCertificateFileName 
         * @param {string} medicalCertificateBeginValidityDate Format is YYYY-MM-DD. &lt;br&gt; There is a bug in some client so the date is sent as string without format:date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMedicalCertificate(access_token: string, personId: number, medicalCertificateFileName: any, medicalCertificateBeginValidityDate: string, options?: any) {
            return PersonsApiFp(configuration).uploadMedicalCertificate(access_token, personId, medicalCertificateFileName, medicalCertificateBeginValidityDate, options)(axios, basePath);
        },
        /**
         * Require PERSON_CREATE right
         * @summary Upload a person\'s photo
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} personId Id of a person
         * @param {any} photoFileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhoto(access_token: string, personId: number, photoFileName: any, options?: any) {
            return PersonsApiFp(configuration).uploadPhoto(access_token, personId, photoFileName, options)(axios, basePath);
        },
    };
};

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * Require PERSON_CREATE right
     * @summary Create a person
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {PersonForCreation} PersonForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public createPerson(access_token: string, PersonForCreation: PersonForCreation, options?: any) {
        return PersonsApiFp(this.configuration).createPerson(access_token, PersonForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_DELETE right
     * @summary Delete a person
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public deletePerson(access_token: string, personId: number, options?: any) {
        return PersonsApiFp(this.configuration).deletePerson(access_token, personId, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_READ right
     * @summary Find all persons
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public findPersons(access_token: string, options?: any) {
        return PersonsApiFp(this.configuration).findPersons(access_token, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_READ right
     * @summary get a person
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(access_token: string, personId: number, options?: any) {
        return PersonsApiFp(this.configuration).getPerson(access_token, personId, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_UPDATE right
     * @summary Update a person
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {PersonForUpdate} PersonForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public updatePerson(access_token: string, personId: number, PersonForUpdate: PersonForUpdate, options?: any) {
        return PersonsApiFp(this.configuration).updatePerson(access_token, personId, PersonForUpdate, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_CREATE right
     * @summary Upload a person\'s medical certificate
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {any} medicalCertificateFileName 
     * @param {string} medicalCertificateBeginValidityDate Format is YYYY-MM-DD. &lt;br&gt; There is a bug in some client so the date is sent as string without format:date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public uploadMedicalCertificate(access_token: string, personId: number, medicalCertificateFileName: any, medicalCertificateBeginValidityDate: string, options?: any) {
        return PersonsApiFp(this.configuration).uploadMedicalCertificate(access_token, personId, medicalCertificateFileName, medicalCertificateBeginValidityDate, options)(this.axios, this.basePath);
    }

    /**
     * Require PERSON_CREATE right
     * @summary Upload a person\'s photo
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} personId Id of a person
     * @param {any} photoFileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public uploadPhoto(access_token: string, personId: number, photoFileName: any, options?: any) {
        return PersonsApiFp(this.configuration).uploadPhoto(access_token, personId, photoFileName, options)(this.axios, this.basePath);
    }

}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {TeamForCreation} TeamForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(access_token: string, clubId: number, seasonId: string, TeamForCreation: TeamForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createTeam.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling createTeam.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling createTeam.');
            }
            // verify required parameter 'TeamForCreation' is not null or undefined
            if (TeamForCreation === null || TeamForCreation === undefined) {
                throw new RequiredError('TeamForCreation','Required parameter TeamForCreation was null or undefined when calling createTeam.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"TeamForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(TeamForCreation !== undefined ? TeamForCreation : {}) : (TeamForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams/{teamId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary find all the club\'s teams
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeams(access_token: string, clubId: number, seasonId: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findTeams.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling findTeams.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling findTeams.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getTeam.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling getTeam.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling getTeam.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling getTeam.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams/{teamId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get team\'s member for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers(access_token: string, clubId: number, seasonId: string, teamId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getTeamMembers.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling getTeamMembers.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling getTeamMembers.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling getTeamMembers.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams/{teamId}/members`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {TeamForUpdate} TeamForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(access_token: string, clubId: number, seasonId: string, teamId: number, TeamForUpdate: TeamForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'clubId' is not null or undefined
            if (clubId === null || clubId === undefined) {
                throw new RequiredError('clubId','Required parameter clubId was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'seasonId' is not null or undefined
            if (seasonId === null || seasonId === undefined) {
                throw new RequiredError('seasonId','Required parameter seasonId was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'teamId' is not null or undefined
            if (teamId === null || teamId === undefined) {
                throw new RequiredError('teamId','Required parameter teamId was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'TeamForUpdate' is not null or undefined
            if (TeamForUpdate === null || TeamForUpdate === undefined) {
                throw new RequiredError('TeamForUpdate','Required parameter TeamForUpdate was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/clubs/{clubId}/seasons/{seasonId}/teams/{teamId}`
                .replace(`{${"clubId"}}`, encodeURIComponent(String(clubId)))
                .replace(`{${"seasonId"}}`, encodeURIComponent(String(seasonId)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"TeamForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(TeamForUpdate !== undefined ? TeamForUpdate : {}) : (TeamForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {TeamForCreation} TeamForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(access_token: string, clubId: number, seasonId: string, TeamForCreation: TeamForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).createTeam(access_token, clubId, seasonId, TeamForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).deleteTeam(access_token, clubId, seasonId, teamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary find all the club\'s teams
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeams(access_token: string, clubId: number, seasonId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).findTeams(access_token, clubId, seasonId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getTeam(access_token, clubId, seasonId, teamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_READ right
         * @summary get team\'s member for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMember>> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).getTeamMembers(access_token, clubId, seasonId, teamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {TeamForUpdate} TeamForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(access_token: string, clubId: number, seasonId: string, teamId: number, TeamForUpdate: TeamForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Team> {
            const localVarAxiosArgs = TeamsApiAxiosParamCreator(configuration).updateTeam(access_token, clubId, seasonId, teamId, TeamForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require CLUB_CREATE right
         * @summary Create the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {TeamForCreation} TeamForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(access_token: string, clubId: number, seasonId: string, TeamForCreation: TeamForCreation, options?: any) {
            return TeamsApiFp(configuration).createTeam(access_token, clubId, seasonId, TeamForCreation, options)(axios, basePath);
        },
        /**
         * Require CLUB_DELETE right
         * @summary Delete the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
            return TeamsApiFp(configuration).deleteTeam(access_token, clubId, seasonId, teamId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary find all the club\'s teams
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTeams(access_token: string, clubId: number, seasonId: string, options?: any) {
            return TeamsApiFp(configuration).findTeams(access_token, clubId, seasonId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary get the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
            return TeamsApiFp(configuration).getTeam(access_token, clubId, seasonId, teamId, options)(axios, basePath);
        },
        /**
         * Require CLUB_READ right
         * @summary get team\'s member for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
            return TeamsApiFp(configuration).getTeamMembers(access_token, clubId, seasonId, teamId, options)(axios, basePath);
        },
        /**
         * Require CLUB_UPDATE right
         * @summary Update the club team for a season
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} clubId Id of a club
         * @param {string} seasonId identifications of the season
         * @param {number} teamId Id of a team
         * @param {TeamForUpdate} TeamForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(access_token: string, clubId: number, seasonId: string, teamId: number, TeamForUpdate: TeamForUpdate, options?: any) {
            return TeamsApiFp(configuration).updateTeam(access_token, clubId, seasonId, teamId, TeamForUpdate, options)(axios, basePath);
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Require CLUB_CREATE right
     * @summary Create the club team for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {TeamForCreation} TeamForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public createTeam(access_token: string, clubId: number, seasonId: string, TeamForCreation: TeamForCreation, options?: any) {
        return TeamsApiFp(this.configuration).createTeam(access_token, clubId, seasonId, TeamForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_DELETE right
     * @summary Delete the club team for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {number} teamId Id of a team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
        return TeamsApiFp(this.configuration).deleteTeam(access_token, clubId, seasonId, teamId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary find all the club\'s teams
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public findTeams(access_token: string, clubId: number, seasonId: string, options?: any) {
        return TeamsApiFp(this.configuration).findTeams(access_token, clubId, seasonId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary get the club team for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {number} teamId Id of a team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeam(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
        return TeamsApiFp(this.configuration).getTeam(access_token, clubId, seasonId, teamId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_READ right
     * @summary get team\'s member for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {number} teamId Id of a team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamMembers(access_token: string, clubId: number, seasonId: string, teamId: number, options?: any) {
        return TeamsApiFp(this.configuration).getTeamMembers(access_token, clubId, seasonId, teamId, options)(this.axios, this.basePath);
    }

    /**
     * Require CLUB_UPDATE right
     * @summary Update the club team for a season
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} clubId Id of a club
     * @param {string} seasonId identifications of the season
     * @param {number} teamId Id of a team
     * @param {TeamForUpdate} TeamForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeam(access_token: string, clubId: number, seasonId: string, teamId: number, TeamForUpdate: TeamForUpdate, options?: any) {
        return TeamsApiFp(this.configuration).updateTeam(access_token, clubId, seasonId, teamId, TeamForUpdate, options)(this.axios, this.basePath);
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Require USER_CREATE right
         * @summary Create a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {UserForCreation} UserForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(access_token: string, UserForCreation: UserForCreation, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling createUser.');
            }
            // verify required parameter 'UserForCreation' is not null or undefined
            if (UserForCreation === null || UserForCreation === undefined) {
                throw new RequiredError('UserForCreation','Required parameter UserForCreation was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"UserForCreation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(UserForCreation !== undefined ? UserForCreation : {}) : (UserForCreation || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require USER_DELETE right
         * @summary Delete a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(access_token: string, userId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require USER_READ right
         * @summary Find all users
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsers(access_token: string, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling findUsers.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require USER_READ right
         * @summary get a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(access_token: string, userId: number, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling getUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Require USER_UPDATE right
         * @summary Update a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {UserForUpdate} UserForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(access_token: string, userId: number, UserForUpdate: UserForUpdate, options: any = {}): RequestArgs {
            // verify required parameter 'access_token' is not null or undefined
            if (access_token === null || access_token === undefined) {
                throw new RequiredError('access_token','Required parameter access_token was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            // verify required parameter 'UserForUpdate' is not null or undefined
            if (UserForUpdate === null || UserForUpdate === undefined) {
                throw new RequiredError('UserForUpdate','Required parameter UserForUpdate was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (access_token !== undefined && access_token !== null) {
                localVarHeaderParameter['access_token'] = String(access_token);
            }


                localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"UserForUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(UserForUpdate !== undefined ? UserForUpdate : {}) : (UserForUpdate || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Require USER_CREATE right
         * @summary Create a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {UserForCreation} UserForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(access_token: string, UserForCreation: UserForCreation, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).createUser(access_token, UserForCreation, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require USER_DELETE right
         * @summary Delete a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(access_token: string, userId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteUser(access_token, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require USER_READ right
         * @summary Find all users
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsers(access_token: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).findUsers(access_token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require USER_READ right
         * @summary get a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(access_token: string, userId: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).getUser(access_token, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Require USER_UPDATE right
         * @summary Update a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {UserForUpdate} UserForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(access_token: string, userId: number, UserForUpdate: UserForUpdate, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).updateUser(access_token, userId, UserForUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Require USER_CREATE right
         * @summary Create a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {UserForCreation} UserForCreation body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(access_token: string, UserForCreation: UserForCreation, options?: any) {
            return UsersApiFp(configuration).createUser(access_token, UserForCreation, options)(axios, basePath);
        },
        /**
         * Require USER_DELETE right
         * @summary Delete a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(access_token: string, userId: number, options?: any) {
            return UsersApiFp(configuration).deleteUser(access_token, userId, options)(axios, basePath);
        },
        /**
         * Require USER_READ right
         * @summary Find all users
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsers(access_token: string, options?: any) {
            return UsersApiFp(configuration).findUsers(access_token, options)(axios, basePath);
        },
        /**
         * Require USER_READ right
         * @summary get a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(access_token: string, userId: number, options?: any) {
            return UsersApiFp(configuration).getUser(access_token, userId, options)(axios, basePath);
        },
        /**
         * Require USER_UPDATE right
         * @summary Update a user
         * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
         * @param {number} userId Id of a user
         * @param {UserForUpdate} UserForUpdate body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(access_token: string, userId: number, UserForUpdate: UserForUpdate, options?: any) {
            return UsersApiFp(configuration).updateUser(access_token, userId, UserForUpdate, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Require USER_CREATE right
     * @summary Create a user
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {UserForCreation} UserForCreation body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(access_token: string, UserForCreation: UserForCreation, options?: any) {
        return UsersApiFp(this.configuration).createUser(access_token, UserForCreation, options)(this.axios, this.basePath);
    }

    /**
     * Require USER_DELETE right
     * @summary Delete a user
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} userId Id of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(access_token: string, userId: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(access_token, userId, options)(this.axios, this.basePath);
    }

    /**
     * Require USER_READ right
     * @summary Find all users
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsers(access_token: string, options?: any) {
        return UsersApiFp(this.configuration).findUsers(access_token, options)(this.axios, this.basePath);
    }

    /**
     * Require USER_READ right
     * @summary get a user
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} userId Id of a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(access_token: string, userId: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(access_token, userId, options)(this.axios, this.basePath);
    }

    /**
     * Require USER_UPDATE right
     * @summary Update a user
     * @param {string} access_token Once the user is logged, the user receive an access token and have to send it for each further requests
     * @param {number} userId Id of a user
     * @param {UserForUpdate} UserForUpdate body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(access_token: string, userId: number, UserForUpdate: UserForUpdate, options?: any) {
        return UsersApiFp(this.configuration).updateUser(access_token, userId, UserForUpdate, options)(this.axios, this.basePath);
    }

}


